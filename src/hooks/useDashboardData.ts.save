 created_at: string;
}

interface Profile {
  id: string;
  email: string;
  full_name: string;
  role: string;
  active: boolean;
}

interface UserGoal {
  user_id: string;
  task_type_id: string;
  daily_goal: number;
  period_goal?: number;
}

interface TaskType {
  id: string;
  name: string;
}

export function useDashboardData(period: PeriodFilter, customRange?: { start: Date; end: Date }) {
  const [activities, setActivities] = useState<ActivityCount[]>([]);
  const [appointments, setAppointments] = useState<Appointment[]>([]);
  const [profiles, setProfiles] = useState<Profile[]>([]);
  const [goals, setGoals] = useState<UserGoal[]>([]);
  const [taskTypes, setTaskTypes] = useState<TaskType[]>([]);
  const [loading, setLoading] = useState(true);

  const getDateRange = useCallback(() => {
    const now = new Date();
    switch (period) {
      case "today":
        return { start: startOfDay(now), end: endOfDay(now) };
      case "week":
        return { start: startOfWeek(now, { weekStartsOn: 1 }), end: endOfWeek(now, { weekStartsOn: 1 }) };
      case "month":
        return { start: startOfMonth(now), end: endOfMonth(now) };
      case "custom":
        return customRange ?? { start: startOfDay(now), end: endOfDay(now) };
      default:
        return { start: startOfMonth(now), end: endOfMonth(now) };
    }
  }, [period, customRange]);

  const fetchData = useCallback(async () => {
    setLoading(true);
    const { start, end } = getDateRange();
    const daysInPeriod = Math.max(1, differenceInDays(end, start) + 1);

    try {
      const [activitiesRes, appointmentsRes, profilesRes, goalsRes, taskTypesRes] = await Promise.all([
        supabase
          .from("activity_logs")
          .select("user_id, action_type")
          .gte("timestamp", start.toISOString())
          .lte("timestamp", end.toISOString()),
        supabase
          .from("appointments")
          .select("*")
          .gte("scheduled_date", start.toISOString())
          .lte("scheduled_date", end.toISOString()),
        supabase.from("profiles").select("*").eq("active", true),
        supabase.from("user_goals").select("*"),
        supabase.from("task_types").select("*"),
      ]);

      if (activitiesRes.error) throw activitiesRes.error;

      const rawActivities = activitiesRes.data ?? [];
      const rawAppointments = (appointmentsRes.data ?? []) as Appointment[];

      // 1. Criar um mapa de contagem real por usu√°rio e tipo
      const userStats = new Map<string, Record<string, number>>();

      // Inicializa estrutura para cada perfil ativo
      (profilesRes.data ?? []).forEach(p => {
        userStats.set(p.id, {
          venda_realizada: 0,
          qualificacao: 0,
          lead_engajado: 0,
          primeiro_contato: 0,
          lead_criado: 0,
          follow_up: 0
        });
      });

      // Contar Vendas (da tabela appointments)
      rawAppointments.forEach(app => {
        if (app.status === "venda_realizada" && userStats.has(app.user_id)) {
          userStats.get(app.user_id)!.venda_realizada++;
        }
      });

      // Contar Atividades (da tabela activity_logs)
      rawActivities.forEach(act => {
        if (userStats.has(act.user_id)) {
          const stats = userStats.get(act.user_id)!;
          if (stats[act.action_type] !== undefined) {
            stats[act.action_type]++;
          } else {
            stats[act.action_type] = 1; // Para outros tipos como follow_up
          }
        }
      });

      // 2. Aplicar L√≥gica de Cascata (Acumulativa)
      const cumulativeCounts: ActivityCount[] = [];

      userStats.forEach((stats, userId) => {
        // A ordem de baixo para cima no funil:
        const v = stats.venda_realizada || 0;
        const q = stats.qualificacao || 0;
        const e = stats.lead_engajado || 0;
        const pc = stats.primeiro_contato || 0;
        const lc = stats.lead_criado || 0;

        // Soma cumulativa (cada etapa inclui todas as etapas abaixo dela)
        const totalQualificacao = q + v;
        const totalEngajado = e + totalQualificacao;
        const totalPrimeiroContato = pc + totalEngajado;
        const totalLeadCriado = lc + totalPrimeiroContato;

        cumulativeCounts.push({ user_id: userId, action_type: "venda_realizada", count: v });
        cumulativeCounts.push({ user_id: userId, action_type: "qualificacao", count: totalQualificacao });
        cumulativeCounts.push({ user_id: userId, action_type: "lead_engajado", count: totalEngajado });
        cumulativeCounts.push({ user_id: userId, action_type: "primeiro_contato", count: totalPrimeiroContato });
        cumulativeCounts.push({ user_id: userId, action_type: "lead_criado", count: totalLeadCriado });
        
        // Follow-up n√£o √© funil, ent√£o permanece contagem real
        cumulativeCounts.push({ user_id: userId, action_type: "follow_up", count: stats.follow_up || 0 });
      });

      const processedGoals = (goalsRes.data ?? []).map((goal: any) => ({
        ...goal,
        period_goal: goal.daily_goal * daysInPeriod
      }));

      setActivities(cumulativeCounts);
      setAppointments(rawAppointments);
      setProfiles((profilesRes.data ?? []) as Profile[]);
      setGoals(processedGoals as UserGoal[]);
      setTaskTypes((taskTypesRes.data ?? []) as TaskType[]);
    } catch (err: any) {
      console.error("üö® Erro ao carregar Dashboard:", err.message);
    } finally {
      setLoading(false);
    }
  }, [getDateRange]);

  useEffect(() => {
    fetchData();
    const actChannel = supabase.channel("activity_changes")
      .on("postgres_changes", { event: "INSERT", schema: "public", table: "activity_logs" }, () => fetchData())
      .subscribe();
    const appChannel = supabase.channel("appointment_changes")
      .on("postgres_changes", { event: "*", schema: "public", table: "appointments" }, () => fetchData())
      .subscribe();
    return () => {
      supabase.removeChannel(actChannel);
      supabase.removeChannel(appChannel);
    };
  }, [fetchData]);

  return { activities, appointments, profiles, goals, taskTypes, loading, refetch: fetchData };
}
